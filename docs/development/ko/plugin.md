# 플러그인 개발 가이드

## 플러그인 작동 방식

`libraries/plugins` 디렉토리의 모든 플러그인은 `CMakeLists.txt`에 의해 반복됩니다. manifest 디렉토리는 모든 플러그인을 반복하여 `steem_plugins` 빌드 대상에 추가합니다. 빌드 시 사용 가능한 모든 플러그인에 액세스하려는 다른 빌드 대상은 이 대상에 링크해야 합니다.

`example_plugins`에 `example_api_plugin`이라는 플러그인이 있으며, 이는 커스텀 API 호출을 추가하는 작동 예제입니다.

## 플러그인 등록

- 플러그인은 `plugins` 설정 파일 옵션으로 활성화됩니다
- 기본적으로 steemd는 `chain`, `p2p`, `webserver` 플러그인을 실행합니다
- 일부 플러그인은 데이터베이스에 레코드를 보관할 수 있습니다 (`account_history` 등). 이러한 플러그인이 비활성화/활성화되었는지 변경하는 경우, 체인도 재생해야 합니다. 이 상황을 감지하고 필요할 때 자동으로 재생하는 기능은 향후 릴리스에서 구현될 예정입니다
- API를 보이게 하려면 `plugins` 설정 파일 옵션에 관련 플러그인을 포함하십시오. 설정을 통해 명시적으로 사용 가능하게 만든 API만 등록됩니다

## 자동 코드 생성

API가 있는 새 플러그인을 만드는 데 필요한 대부분의 보일러플레이트를 포함하는 스켈레톤 구조는 `programs/utils/newplugin.py`를 실행하여 자동 생성할 수 있습니다.

**모범 사례:**

- 필요한 경우 `plugin_initialize()`에 신호 핸들러 및 커스텀 evaluator 등록
- `plugin_initialize()`에 API 등록
- API 플러그인은 액세스 권한을 부여하는 상태 저장 플러그인과 분리되어야 합니다. 이를 통해 플러그인의 상태를 추적하면서 API를 비활성화할 수 있습니다

## 플러그인의 시작/종료

### 의존성

- 플러그인은 `APPBASE_PLUGIN_REQUIRES` 매크로로 의존성을 지정할 수 있으며, 이는 의존성 목록을 받습니다
- 순환 의존성이 있는 경우 정의되지 않은 동작이 있습니다. 순환 의존성을 제거하도록 플러그인 간 데이터 흐름을 설계할 때 주의하십시오
- `plugin_initialize` 및 `plugin_startup` 모두 의존 플러그인이 호출되기 전에 모든 의존성이 이미 초기화되거나 시작되었음을 보장합니다
- `plugin_shutdown`은 시작과 반대 순서로 호출됩니다. shutdown이 호출될 때 모든 의존성은 여전히 실행 중입니다

### 플러그인 액세스

- `appbase::app().get_plugin<PLUGIN>()`으로 플러그인에 대한 참조를 얻거나 `appbase::app().find_plugin<PLUGIN>()`으로 포인터를 얻을 수 있습니다
- `get_plugin`은 실패하고 `find_plugin`은 플러그인이 등록되지 않았거나 초기화되지 않은 경우 nullptr을 반환합니다
- 이러한 메서드는 초기화된 데이터에 액세스하고 있음을 보장합니다
- 초기화 순서 때문에 초기화, 시작 및 종료에서 의존성에 대해 get/find_plugin을 호출하는 것이 안전합니다
- 선택적 의존성에 대해 시작에서만 get/find_plugin을 호출하는 것이 안전합니다. 선택적 의존성은 명시적으로 지정되지 않습니다. 플러그인이 활성화된 경우 일부 선택적 동작일 뿐입니다

## 비동기 API

- json rpc 플러그인은 API 요청을 비동기적으로 디스패치합니다. 이는 API 호출이 선점되거나 지연될 수 있으며 병렬성을 염두에 두고 설계되어야 함을 의미합니다
- 도움을 위해 chainbase는 간단한 읽기/쓰기 잠금 메커니즘을 제공합니다: `with_read_lock` 및 `with_write_lock`
- 이것은 전체 데이터베이스에 대한 전역 잠금입니다
- 메서드는 잠금으로 보호될 람다를 받습니다. 대부분의 API 호출에는 `with_read_lock`이 충분합니다
- 일관된 블록 시간을 보장하기 위해 읽기 잠금은 1초 후 자동으로 만료됩니다. 이를 염두에 두고 API 호출을 설계하십시오. API 호출이 1초 이상 걸리면 결과가 정의되지 않습니다. API 호출이 1초 이상 실행되지 않도록 제한을 만드는 것이 가장 좋습니다 (250ms 미만이 바람직함)
