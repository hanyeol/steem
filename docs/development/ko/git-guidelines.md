SteemIt의 git 가이드라인은
[Graphene](https://github.com/cryptonomex/graphene/wiki/How-we-use-version-control)
git 가이드라인과 [Git
Flow](http://nvie.com/posts/a-successful-git-branching-model/) 및 [이
블로그
포스트](http://www.draconianoverlord.com/2013/09/07/no-cherry-picking.html)의 영향을 받았습니다.

## 브랜치
- `stable`: 프로덕션 준비가 되어 있고 프로덕션에서 테스트된 최신 버전의 코드를 가리킵니다.
 증인, 거래소, 시드 노드 및 RPC 노드는 이 브랜치를 실행해야 합니다.
- `main`: Steem의 현재 릴리스를 가리킵니다. 각 릴리스 커밋은
  `vMajor.Hardfork.Release`로 태그됩니다. 릴리스 준비가 되면
  feature 브랜치를 `develop`에 머지한 다음 Pull Request를 통해
  `main`에 단일 머지를 수행합니다. `main`에 대한 모든 PR은
  자동화된 테스트를 통과해야 머지됩니다.
- `develop`: 활성 개발 브랜치입니다. 우리는 `develop`을
  작동 상태로 유지하기 위해 노력합니다. 모든 PR은 머지되기 전에
  자동화된 테스트를 통과해야 합니다. 이것이 `develop`에 버그가 없다는 보장은 아니지만,
  브랜치가 표준 빌드 구성에서 빌드 가능하고 현재 테스트 스위트를
  통과한다는 것을 보장합니다. 그렇긴 하지만, `develop`에서 노드를 실행하는 것은
  위험이 있습니다. 블록 생성 노드는
  `stable`에서 빌드하는 것을 권장합니다. 새로운 기능을 테스트하려면 develop이
  올바른 브랜치입니다.

### 패치 브랜치

모든 변경 사항은 자체 브랜치에서 개발되어야 합니다. 이러한 브랜치는
`develop`에서 분기한 다음 테스트되고 준비가 되면
`develop`으로 다시 머지되어야 합니다. 이슈가 다른 이슈를
종속성으로 필요로 하는 경우, `develop`에서 분기하고 종속 이슈 브랜치를 새 브랜치에
머지한 다음 개발을 시작합니다. 우리가 사용하는 명명 체계는 이슈
번호, 대시, 이슈에 대한 약식 설명입니다. 예를 들어,
이슈 22는 upvote 제거를 허용하는 것입니다. 이 이슈에 대한 패치를 개발하기 위해
`22-undo-vote` 브랜치가 사용되었습니다.

### Non-Issue 브랜치

일부 변경 사항은 이슈가 필요하지 않을 정도로 사소합니다 (예: 로깅 변경).
자동화된 테스트 요구사항 때문에 이에 대한 이슈를 생성합니다. 우리는 과소 문서화보다
과다 문서화 측면에서 오류를 냅니다. `develop`에서 분기하고 수정하고
`develop`에 pull request를 생성합니다.

이슈가 없는 이러한 브랜치에 대한 제안된 형식은
`YYYYMMDD-shortname`입니다 (예: `20160913-documentation-update`). (브랜치의 날짜는
주기적으로 오래되거나 사용되지 않는 것을 정리하여 repo를 깔끔하게 유지할 수 있도록 하기 위함입니다.)

## Pull Requests

`develop` 및 `main`에 대한 모든 변경은 GitHub Pull Requests
(PRs)를 통해 수행됩니다. 이는 여러 이유로 수행됩니다:

- 2단계 인증을 강제합니다. GitHub은 인터페이스를 통해서만 pull request의
  머지를 허용하며, 이는 개발자가 로그인해야 합니다.
- 테스트를 강제합니다. 모든 pull request는 머지가 허용되기 전에
  자동화된 테스트를 거칩니다.
- 모범 사례를 강제합니다. pull request의 비용 때문에
  개발자는 스스로 더 많은 테스트를 수행하고 솔루션의 정확성을 확신하도록 권장됩니다.
- 코드 리뷰를 강제합니다. 모든 pull request는 요청 작성자가 아닌
  다른 개발자가 검토해야 합니다. 외부 개발자가 작성한 Pull request는
  두 명의 내부 개발자가 검토해야 합니다. 개발자가 pull request를 검토하고 승인할 때
  요청에 +1을 추가하거나 승인을 언급하는 댓글을 남겨야 합니다.
  그렇지 않으면 요청의 문제를 설명하여 개발자가 변경하고
  요청을 재제출할 수 있도록 해야 합니다.

모든 pull request는 문서 체인을 생성하기 위해 관련 이슈를 참조해야 합니다.

pull request에 머지 충돌이 있는 경우, `origin/develop`에 대해 rebase하고
머지 충돌을 해결하고 브랜치에 force push한 다음 pull request를
재제출합니다.

## 정책

### Force-Push 정책

- `origin/master`는 절대 force push되어서는 안 됩니다.
- `origin/develop`은 절대 force push되어서는 안 됩니다. `develop`에 대한 모든 업데이트는
  PR을 통해 수행되므로 force push는 허용되지 않습니다.
- 개별 패치 브랜치는 패치를 작업하는 개발자 또는 팀의 재량에 따라
  언제든지 force push될 수 있습니다.

### 태깅 정책

- 태그는 릴리스용으로 예약되어 있습니다. 버전 체계는
  `vMajor.Hardfork.Release`입니다 (예: v0.5.0은 Hardfork 5
  릴리스의 버전입니다). 릴리스는 `main`에서만 수행되어야 합니다.

### 코드 리뷰 정책 / PR 머지 프로세스

- 두 명의 개발자가 `main`에 머지하기 전에 *모든* 릴리스를 *반드시* 검토해야 하며,
  pull request를 통해 강제됩니다.
- 두 명의 개발자가 `develop`으로 이동하기 전에 *모든* 합의 변경 사항을
  *반드시* 검토해야 하며, pull request를 통해 강제됩니다.
- 두 명의 개발자가 `develop`으로 이동하기 전에 *모든* 패치를
  *검토해야 하며*, pull request를 통해 강제됩니다.
- 검토자 중 한 명은 변경 사항의 작성자일 수 있습니다.
- 이 정책은 "작가 모자"를 벗고 "비평가/검토자 모자"를 쓰도록
  권장하기 위해 설계되었습니다. 이것이 익숙하지 않은 커뮤니티 기여자의
  패치였다면 수락하시겠습니까? 커밋
  메시지와 diff만으로 패치가 무엇을 하는지 이해하고 정확성을 확인할 수 있습니까?
  기존 테스트를 깨뜨리거나 새 테스트를 작성해야 합니까? 스타일상 지저분합니까 --
  후행 공백, 단일 패치의 여러 관련 없는 변경, 버그 수정과 기능 혼합,
  또는 과도하게 자세한 디버그 로깅?
- 여러 사람이 패치를 검토하면 감지되지 않은 버그가 포함될 확률이
  줄어듭니다.
